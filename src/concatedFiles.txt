File: GeneticAlgorithm.java
**************************************************
package Algorithms;
import Model.Assignment;
import Model.Employee;
import Model.Task;
import Utilities.CostCalculator;
import Utilities.ConstraintValidator;
import Utilities.Initialise;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

/**
 * Genetic Algorithm implementation for employee-task assignment optimization.
 * Adapted from a solution originally designed for the 8-Queens problem.
 */
public class GeneticAlgorithm implements Algorithm
{
    // Algorithm parameters
    private final int populationSize;
    private final double crossoverRate;
    private final double mutationRate;
    private final int maxGenerations;
    private final int elitismCount;
    private final boolean fileOutput;

    // Problem data
    private final List<Task> tasks;
    private final List<Employee> employees;

    // Tracking and reporting
    private String output = "";
    private Assignment globalBestAssignment;
    private double globalBestCost = Double.MAX_VALUE;
    private List<Double> bestCostHistory = new ArrayList<>();
    private List<Double> avgCostHistory = new ArrayList<>();
    private List<Integer> feasibleSolutionsHistory = new ArrayList<>();

    /**
     * Constructor for the Genetic Algorithm.
     *
     * @param tasks          The list of tasks to be assigned
     * @param employees      The list of employees available for assignment
     * @param populationSize Size of the population (number of solutions)
     * @param crossoverRate  Probability of crossover (0.0-1.0)
     * @param mutationRate   Probability of mutation (0.0-1.0)
     * @param maxGenerations Maximum number of generations to run
     * @param fileOutput     Whether to output results to a file
     */
    public GeneticAlgorithm(List<Task> tasks, List<Employee> employees,
                            int populationSize, double crossoverRate, double mutationRate,
                            int maxGenerations, boolean fileOutput)
    {
        this.tasks = tasks;
        this.employees = employees;
        this.populationSize = populationSize;
        this.crossoverRate = crossoverRate;
        this.mutationRate = mutationRate;
        if(maxGenerations == -1)
        {
            this.maxGenerations = Integer.MAX_VALUE;
        }
        else{
            this.maxGenerations = maxGenerations;
        }
        this.elitismCount = 2; // Keep the best 2 solutions
        this.fileOutput = fileOutput;
    }

    /**
     * Generates a random employee index within the valid range.
     *
     * @return A random employee index
     */
    private int getRandomEmployeeIndex()
    {
        return new Random().nextInt(employees.size());
    }



    /**
     * Runs the genetic algorithm to find an optimal assignment.
     *
     * @return The best Assignment found
     */
    @Override
    public Assignment run()
    {
        // Initialize population
        List<Assignment> population = Initialise.getInitialPopulation(employees, tasks, populationSize);
        // Evaluate initial population
        evaluatePopulation(population);

        int generation = 0;
        globalBestAssignment = findBestAssignment(population);
        globalBestCost = globalBestAssignment.calculateCost(employees, tasks);

        recordStatistics(population, generation);

        // Main loop
        while (generation < maxGenerations && !terminationCondition(population))
        {
            List<Assignment> newPopulation = new ArrayList<>();

            // Sort population by fitness (lower cost is better)
            sortPopulationByFitness(population);

            // Add elite solutions to new population
            for (int i = 0; i < elitismCount && i < population.size(); i++)
            {
                newPopulation.add(new Assignment(population.get(i)));
            }

            // Fill the rest of the population with offspring
            while (newPopulation.size() < populationSize)
            {
                // Selection
                Assignment[] parents = selectParents(population);
                Assignment parent1 = parents[0];
                Assignment parent2 = parents[1];

                // Crossover
                Assignment offspring1 = null;
                Assignment offspring2 = null;

                if (Math.random() < crossoverRate)
                {
                    offspring1 = crossover(parent1, parent2);
                    offspring2 = crossover(parent2, parent1);
                }
                else
                {
                    offspring1 = new Assignment(parent1);
                    offspring2 = new Assignment(parent2);
                }

                // Mutation
                mutate(offspring1);
                mutate(offspring2);

                // Add to new population
                if (newPopulation.size() < populationSize)
                {
                    newPopulation.add(offspring1);
                }
                if (newPopulation.size() < populationSize)
                {
                    newPopulation.add(offspring2);
                }
            }

            // Replace old population with new population
            population = newPopulation;

            // Evaluate new population
            evaluatePopulation(population);

            // Update global best
            Assignment currentBest = findBestAssignment(population);
            double currentBestCost = currentBest.calculateCost(employees, tasks);

            if (currentBestCost < globalBestCost)
            {
                globalBestAssignment = new Assignment(currentBest);
                globalBestCost = currentBestCost;
            }

            // Record statistics
            recordStatistics(population, generation);

            // Print progress
            if (generation % 10 == 0 || generation == maxGenerations - 1)
            {
                printProgress(currentBest, generation);
            }

            generation++;
        }

        // Print final result
        printFinalResult(globalBestAssignment, generation);

        return globalBestAssignment;
    }

    /**
     * Records statistics for the current generation.
     *
     * @param population The current population
     * @param generation The current generation number
     */
    private void recordStatistics(List<Assignment> population, int generation)
    {
        // Record best cost
        double bestCost = findBestAssignment(population).calculateCost(employees, tasks);
        bestCostHistory.add(bestCost);

        // Record average cost
        double totalCost = 0;
        for (Assignment assignment : population)
        {
            totalCost += assignment.calculateCost(employees, tasks);
        }
        double avgCost = totalCost / population.size();
        avgCostHistory.add(avgCost);

        // Record feasible solutions count
        int feasibleCount = 0;
        for (Assignment assignment : population)
        {
            if (ConstraintValidator.isAssignmentFeasible(assignment, tasks, employees))
            {
                feasibleCount++;
            }
        }
        feasibleSolutionsHistory.add(feasibleCount);
    }

    /**
     * Evaluates the fitness of all assignments in the population.
     *
     * @param population The population to evaluate
     */
    private void evaluatePopulation(List<Assignment> population)
    {
        for (Assignment assignment : population)
        {
            // Fitness is already calculated when needed by the Assignment class
            // This is just a placeholder in case preprocessing is needed
        }
    }

    /**
     * Sorts the population by fitness (lower cost is better).
     *
     * @param population The population to sort
     */
    private void sortPopulationByFitness(List<Assignment> population)
    {
        population.sort(Comparator.comparingDouble(a -> a.calculateCost(employees, tasks)));
    }

    /**
     * Finds the best assignment in the population.
     *
     * @param population The population to search
     * @return The best Assignment
     */
    private Assignment findBestAssignment(List<Assignment> population)
    {
        Assignment best = population.get(0);
        double bestCost = best.calculateCost(employees, tasks);

        for (int i = 1; i < population.size(); i++)
        {
            Assignment current = population.get(i);
            double currentCost = current.calculateCost(employees, tasks);

            if (currentCost < bestCost)
            {
                best = current;
                bestCost = currentCost;
            }
        }

        return best;
    }

    /**
     * Selects two parent assignments using tournament selection.
     *
     * @param population The population to select from
     * @return Array of two selected parent Assignments
     */
    private Assignment[] selectParents(List<Assignment> population)
    {
        Assignment[] parents = new Assignment[2];

        // Tournament selection
        for (int i = 0; i < 2; i++)
        {
            int tournamentSize = 3;
            List<Assignment> tournament = new ArrayList<>();

            for (int j = 0; j < tournamentSize; j++)
            {
                int randomIndex = new Random().nextInt(population.size());
                tournament.add(population.get(randomIndex));
            }

            parents[i] = findBestAssignment(tournament);
        }

        return parents;
    }

    /**
     * Performs crossover between two parent assignments.
     *
     * @param parent1 The first parent Assignment
     * @param parent2 The second parent Assignment
     * @return A new Assignment created by crossover
     */
    private Assignment crossover(Assignment parent1, Assignment parent2)
    {
        Assignment offspring = new Assignment();

        // Uniform crossover - for each task, choose assignment from either parent1 or parent2
        for (Task task : tasks)
        {
            String taskId = task.getId();

            if (Math.random() < 0.5)
            {
                offspring.assign(taskId, parent1.getAssignedEmployee(taskId));
            }
            else
            {
                offspring.assign(taskId, parent2.getAssignedEmployee(taskId));
            }
        }

        return offspring;
    }

    /**
     * Applies mutation to an assignment.
     *
     * @param assignment The Assignment to mutate
     */
    private void mutate(Assignment assignment)
    {
        for (Task task : tasks)
        {
            if (Math.random() < mutationRate)
            {
                // Mutate this task by assigning it to a random employee
                String employeeId = employees.get(Initialise.getRandomEmployeeIndex(employees.size())).getId();
                assignment.assign(task.getId(), employeeId);
            }
        }

        // Additional mutation: swap tasks between employees
        if (Math.random() < mutationRate / 2 && tasks.size() >= 2)
        {
            int taskIndex1 = new Random().nextInt(tasks.size());
            int taskIndex2 = new Random().nextInt(tasks.size());

            if (taskIndex1 != taskIndex2)
            {
                String taskId1 = tasks.get(taskIndex1).getId();
                String taskId2 = tasks.get(taskIndex2).getId();

                String employeeId1 = assignment.getAssignedEmployee(taskId1);
                String employeeId2 = assignment.getAssignedEmployee(taskId2);

                assignment.assign(taskId1, employeeId2);
                assignment.assign(taskId2, employeeId1);
            }
        }
    }

    /**
     * Checks if termination condition is met.
     *
     * @param population The current population
     * @return true if termination condition is met, false otherwise
     */
    private boolean terminationCondition(List<Assignment> population)
    {
        // Check if we have a perfect solution (zero cost)
        for (Assignment assignment : population)
        {
            if (assignment.calculateCost(employees, tasks) == 0)
            {
                return true;
            }
        }

        return false;
    }

    /**
     * Prints the progress of the current generation.
     *
     * @param bestAssignment The best Assignment in the current generation
     * @param generation     The current generation number
     */
    private void printProgress(Assignment bestAssignment, int generation)
    {
        StringBuilder sb = new StringBuilder();
        double cost = bestAssignment.calculateCost(employees, tasks);

        sb.append("Generation ").append(generation)
                .append(": Best Cost = ").append(String.format("%.2f", cost))
                .append(", Feasible: ").append(ConstraintValidator.isAssignmentFeasible(bestAssignment, tasks, employees))
                .append("\n");

        output += sb.toString();

        if (!fileOutput)
        {
            System.out.print(sb.toString());
        }
    }

    /**
     * Prints the final result of the algorithm.
     *
     * @param bestAssignment The best Assignment found
     * @param generation     The final generation number
     */
    private void printFinalResult(Assignment bestAssignment, int generation)
    {
        StringBuilder sb = new StringBuilder();
        double cost = bestAssignment.calculateCost(employees, tasks);

        sb.append("\n=================================\n");
        sb.append("Final Result after ").append(generation).append(" generations:\n");
        sb.append("=================================\n");
        sb.append("Total Cost: ").append(String.format("%.2f", cost)).append("\n");
        sb.append("Feasible Solution: ").append(ConstraintValidator.isAssignmentFeasible(bestAssignment, tasks, employees)).append("\n\n");

        // Print assignments
        sb.append("Task Assignments:\n");
        for (Task task : tasks)
        {
            String taskId = task.getId();
            String employeeId = bestAssignment.getAssignedEmployee(taskId);

            Employee employee = findEmployeeById(employeeId);

            sb.append("  Task ").append(taskId)
                    .append(" (Time: ").append(task.getEstimatedTime())
                    .append(", Difficulty: ").append(task.getDifficulty())
                    .append(", Skill: ").append(task.getRequiredSkill())
                    .append(") -> Employee ").append(employeeId)
                    .append(" (Skill Level: ").append(employee.getSkillLevel())
                    .append(", Has Required Skill: ").append(employee.hasSkill(task.getRequiredSkill()))
                    .append(")\n");
        }

        // Print workload distribution
        sb.append("\nWorkload Distribution:\n");
        Map<String, Integer> employeeWorkload = new HashMap<>();

        for (Employee employee : employees)
        {
            String employeeId = employee.getId();
            int totalTime = bestAssignment.calculateTotalWorkingTime(employeeId, tasks);
            employeeWorkload.put(employeeId, totalTime);

            sb.append("  Employee ").append(employeeId)
                    .append(": ").append(totalTime)
                    .append(" / ").append(employee.getAvailableHours())
                    .append(" hours (")
                    .append(String.format("%.1f", (double) totalTime / employee.getAvailableHours() * 100))
                    .append("%)");

            if (totalTime > employee.getAvailableHours())
            {
                sb.append(" - OVERLOADED");
            }

            sb.append("\n");
        }

        // Print penalty breakdown
        sb.append("\nPenalty Breakdown:\n");
        double overloadPenalty = 0;
        for (Employee employee : employees)
        {
            overloadPenalty += bestAssignment.calculateOverloadPenalty(employee, tasks);
        }

        double skillMismatchPenalty = bestAssignment.calculateSkillMismatchPenalty(employees, tasks);
        double deadlineViolationPenalty = bestAssignment.calculateDeadlineViolationPenalty(employees, tasks);

        sb.append("  Overload Penalty: ").append(String.format("%.2f", overloadPenalty)).append("\n");
        sb.append("  Skill Mismatch Penalty: ").append(String.format("%.2f", skillMismatchPenalty)).append("\n");
        sb.append("  Deadline Violation Penalty: ").append(String.format("%.2f", deadlineViolationPenalty)).append("\n");

        output += sb.toString();

        if (fileOutput)
        {
            System.out.println(sb.toString());
            writeToFile();
        }
        else
        {
            System.out.println(sb.toString());
        }
    }

    /**
     * Helper method to find an employee by ID.
     *
     * @param employeeId The ID of the employee to find
     * @return The Employee with the specified ID, or null if not found
     */
    private Employee findEmployeeById(String employeeId)
    {
        for (Employee employee : employees)
        {
            if (employee.getId().equals(employeeId))
            {
                return employee;
            }
        }
        return null;
    }

    /**
     * Writes output to a file.
     */
    private void writeToFile()
    {
        String fileName = "results/ga_results.txt";

        String extension = "";
        String name = "";

        int idxOfDot = fileName.lastIndexOf('.');
        extension = fileName.substring(idxOfDot + 1);
        name = fileName.substring(0, idxOfDot);

        Path path = Paths.get(fileName);
        int counter = 1;
        File f = null;

        // Create directories if they don't exist
        File dir = new File("results");
        if (!dir.exists())
        {
            dir.mkdirs();
        }

        while (Files.exists(path))
        {
            fileName = name + "(" + counter + ")." + extension;
            path = Paths.get(fileName);
            counter++;
        }
        f = new File(fileName);

        try (FileWriter fw = new FileWriter(f))
        {
            fw.write(output);
        }
        catch (IOException e)
        {
            System.out.println("Error writing to file: " + e.getMessage());
        }
    }

    /**
     * Gets the best cost history for reporting.
     *
     * @return List of best cost values per generation
     */
    @Override
    public List<Double> getBestCostHistory()
    {
        return bestCostHistory;
    }

    /**
     * Gets the average cost history for reporting.
     *
     * @return List of average cost values per generation
     */
    @Override
    public List<Double> getAvgCostHistory()
    {
        return avgCostHistory;
    }

    /**
     * Gets the feasible solutions history for reporting.
     *
     * @return List of feasible solution counts per generation
     */
    @Override
    public List<Integer> getFeasibleSolutionsHistory()
    {
        return feasibleSolutionsHistory;
    }
}
**************************************************

File: Algorithm.java
**************************************************
package Algorithms;

import Model.Assignment;

import java.util.List;

public interface Algorithm
{
    /**
     * Runs the genetic algorithm to find an optimal assignment.
     *
     * @return The best Assignment found
     */
    Assignment run();

    /**
     * Gets the best cost history throughout the optimization process.
     * This is used for performance evaluation and visualization.
     *
     * @return List of best cost values per iteration/generation
     */
    List<Double> getBestCostHistory();

    /**
     * Gets the average cost history throughout the optimization process.
     * This is used for performance evaluation and visualization.
     *
     * @return List of average cost values per iteration/generation
     */
    List<Double> getAvgCostHistory();

    /**
     * Gets the feasible solutions history throughout the optimization process.
     * This tracks how many solutions satisfy all constraints at each iteration.
     *
     * @return List of feasible solution counts per iteration/generation
     */
    List<Integer> getFeasibleSolutionsHistory();
}
**************************************************

File: CostCalculator.java
**************************************************
package Utilities;

import Model.Assignment;
import Model.Employee;
import Model.Task;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Utility class for calculating costs and penalties in the task assignment problem.
 */
public class CostCalculator {

    // Penalty weighting factors as defined in the problem specification
    private static final double OVERLOAD_WEIGHT = 0.33;
    private static final double SKILL_MISMATCH_WEIGHT = 0.33;
    private static final double DEADLINE_VIOLATION_WEIGHT = 0.34;

    /**
     * Calculates the total cost of an assignment.
     * Cost = α × (Overload Penalty) + β × (Skill Mismatch Penalty) + γ × (Deadline Violation Penalty)
     *
     * @param assignment The Assignment to evaluate
     * @param tasks The list of all tasks
     * @param employees The list of all employees
     * @return The total cost of the assignment
     */
    public static double calculateTotalCost(Assignment assignment, List<Task> tasks, List<Employee> employees) {
        double overloadPenalty = calculateOverloadPenalty(assignment, tasks, employees);
        double skillMismatchPenalty = calculateSkillMismatchPenalty(assignment, tasks, employees);
        double deadlineViolationPenalty = calculateDeadlineViolationPenalty(assignment, tasks, employees);

        return (OVERLOAD_WEIGHT * overloadPenalty) +
                (SKILL_MISMATCH_WEIGHT * skillMismatchPenalty) +
                (DEADLINE_VIOLATION_WEIGHT * deadlineViolationPenalty);
    }

    /**
     * Calculates the overload penalty.
     * This penalty occurs when an employee is assigned more work than their available hours.
     *
     * @param assignment The Assignment to evaluate
     * @param tasks The list of all tasks
     * @param employees The list of all employees
     * @return The overload penalty
     */
    public static double calculateOverloadPenalty(Assignment assignment, List<Task> tasks, List<Employee> employees) {
        double totalPenalty = 0;

        for (Employee employee : employees) {
            int totalWorkload = calculateEmployeeWorkload(assignment, tasks, employee.getId());
            int overload = Math.max(0, totalWorkload - employee.getAvailableHours());
            totalPenalty += overload;
        }

        return totalPenalty;
    }

    /**
     * Calculates the skill mismatch penalty.
     * This penalty occurs when tasks are assigned to employees who:
     * 1. Have a skill level lower than the task's difficulty
     * 2. Don't possess the specific skill required by the task
     *
     * @param assignment The Assignment to evaluate
     * @param tasks The list of all tasks
     * @param employees The list of all employees
     * @return The skill mismatch penalty
     */
    public static double calculateSkillMismatchPenalty(Assignment assignment, List<Task> tasks, List<Employee> employees) {
        int mismatchCount = 0;

        for (Task task : tasks) {
            String employeeId = assignment.getAssignedEmployee(task.getId());
            if (employeeId != null) {
                Employee employee = findEmployeeById(employees, employeeId);

                if (employee != null) {
                    // Check skill level constraint
                    if (employee.getSkillLevel() < task.getDifficulty()) {
                        mismatchCount++;
                    }

                    // Check specialized skill constraint
                    if (!employee.hasSkill(task.getRequiredSkill())) {
                        mismatchCount++;
                    }
                }
            }
        }

        return mismatchCount;
    }

    /**
     * Calculates the deadline violation penalty.
     * This penalty occurs when a task is projected to be completed after its deadline.
     *
     * @param assignment The Assignment to evaluate
     * @param tasks The list of all tasks
     * @param employees The list of all employees
     * @return The deadline violation penalty
     */
    public static double calculateDeadlineViolationPenalty(Assignment assignment, List<Task> tasks, List<Employee> employees) {
        int violationCount = 0;

        // For each employee, track their current workload time
        Map<String, Integer> employeeWorkloadTimes = new HashMap<>();

        // For simplicity, assume tasks are processed in order by ID
        // A more sophisticated approach might involve scheduling algorithms
        List<Task> sortedTasks = tasks.stream()
                .sorted((t1, t2) -> t1.getId().compareTo(t2.getId()))
                .toList();

        for (Task task : sortedTasks) {
            String employeeId = assignment.getAssignedEmployee(task.getId());
            if (employeeId != null) {
                // Initialize workload time if not already present
                employeeWorkloadTimes.putIfAbsent(employeeId, 0);

                // Get current workload time for the employee
                int currentWorkloadTime = employeeWorkloadTimes.get(employeeId);

                // Add the task's estimated time to the workload
                currentWorkloadTime += task.getEstimatedTime();

                // Check if the deadline is violated
                if (currentWorkloadTime > task.getDeadline()) {
                    violationCount++;
                }

                // Update the workload time
                employeeWorkloadTimes.put(employeeId, currentWorkloadTime);
            }
        }

        return violationCount;
    }

    /**
     * Calculates the total workload assigned to an employee.
     *
     * @param assignment The Assignment to evaluate
     * @param tasks The list of all tasks
     * @param employeeId The ID of the employee
     * @return The total workload in hours
     */
    public static int calculateEmployeeWorkload(Assignment assignment, List<Task> tasks, String employeeId) {
        int totalWorkload = 0;

        for (Task task : tasks) {
            String assignedEmployeeId = assignment.getAssignedEmployee(task.getId());
            if (employeeId.equals(assignedEmployeeId)) {
                totalWorkload += task.getEstimatedTime();
            }
        }

        return totalWorkload;
    }

    /**
     * Helper method to find an employee by ID.
     *
     * @param employees The list of all employees
     * @param employeeId The ID of the employee to find
     * @return The employee with the specified ID, or null if not found
     */
    private static Employee findEmployeeById(List<Employee> employees, String employeeId) {
        for (Employee employee : employees) {
            if (employee.getId().equals(employeeId)) {
                return employee;
            }
        }
        return null;
    }
}
**************************************************

File: ConstraintValidator.java
**************************************************
package Utilities;


import Model.Assignment;
import Model.Employee;
import Model.Task;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Utility class for validating constraints in the task assignment problem.
 */
public class ConstraintValidator {

    /**
     * Checks if an assignment satisfies all constraints.
     *
     * @param assignment The Assignment to validate
     * @param tasks The list of all tasks
     * @param employees The list of all employees
     * @return true if the assignment is feasible, false otherwise
     */
    public static boolean isAssignmentFeasible(Assignment assignment, List<Task> tasks, List<Employee> employees) {
        return isUniqueAssignment(assignment, tasks) &&
                isCapacityRespected(assignment, tasks, employees) &&
                isSkillLevelSufficient(assignment, tasks, employees) &&
                isSkillMatchingRespected(assignment, tasks, employees);
    }

    /**
     * Checks if each task is assigned to exactly one employee.
     *
     * @param assignment The Assignment to validate
     * @param tasks The list of all tasks
     * @return true if constraint is satisfied, false otherwise
     */
    public static boolean isUniqueAssignment(Assignment assignment, List<Task> tasks) {
        for (Task task : tasks) {
            if (assignment.getAssignedEmployee(task.getId()) == null) {
                return false;
            }
        }
        return true;
    }

    /**
     * Checks if the capacity constraint is respected.
     * The total time assigned to an employee must not exceed their available hours.
     *
     * @param assignment The Assignment to validate
     * @param tasks The list of all tasks
     * @param employees The list of all employees
     * @return true if constraint is satisfied, false otherwise
     */
    public static boolean isCapacityRespected(Assignment assignment, List<Task> tasks, List<Employee> employees) {
        Map<String, Integer> employeeWorkload = new HashMap<>();

        // Initialize workload map
        for (Employee employee : employees) {
            employeeWorkload.put(employee.getId(), 0);
        }

        // Calculate workload for each employee
        for (Task task : tasks) {
            String employeeId = assignment.getAssignedEmployee(task.getId());
            if (employeeId != null) {
                int currentWorkload = employeeWorkload.getOrDefault(employeeId, 0);
                employeeWorkload.put(employeeId, currentWorkload + task.getEstimatedTime());
            }
        }

        // Check if workload exceeds capacity
        for (Employee employee : employees) {
            int workload = employeeWorkload.getOrDefault(employee.getId(), 0);
            if (workload > employee.getAvailableHours()) {
                return false;
            }
        }

        return true;
    }

    /**
     * Checks if the skill level constraint is respected.
     * An employee can only be assigned a task if their skill level is at least equal to the task's difficulty.
     *
     * @param assignment The Assignment to validate
     * @param tasks The list of all tasks
     * @param employees The list of all employees
     * @return true if constraint is satisfied, false otherwise
     */
    public static boolean isSkillLevelSufficient(Assignment assignment, List<Task> tasks, List<Employee> employees) {
        for (Task task : tasks) {
            String employeeId = assignment.getAssignedEmployee(task.getId());
            if (employeeId != null) {
                Employee employee = findEmployeeById(employees, employeeId);
                if (employee != null && employee.getSkillLevel() < task.getDifficulty()) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Checks if the specialized skill matching constraint is respected.
     * A task requiring a specific skill may only be assigned to an employee who possesses that skill.
     *
     * @param assignment The Assignment to validate
     * @param tasks The list of all tasks
     * @param employees The list of all employees
     * @return true if constraint is satisfied, false otherwise
     */
    public static boolean isSkillMatchingRespected(Assignment assignment, List<Task> tasks, List<Employee> employees) {
        for (Task task : tasks) {
            String employeeId = assignment.getAssignedEmployee(task.getId());
            if (employeeId != null) {
                Employee employee = findEmployeeById(employees, employeeId);
                if (employee != null && !employee.hasSkill(task.getRequiredSkill())) {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * Helper method to find an employee by ID.
     *
     * @param employees The list of all employees
     * @param employeeId The ID of the employee to find
     * @return The employee with the specified ID, or null if not found
     */
    private static Employee findEmployeeById(List<Employee> employees, String employeeId) {
        for (Employee employee : employees) {
            if (employee.getId().equals(employeeId)) {
                return employee;
            }
        }
        return null;
    }
}
**************************************************

File: Initialise.java
**************************************************
package Utilities;

import Model.Assignment;
import Model.Employee;
import Model.Task;

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class Initialise
{

    public static int getRandomEmployeeIndex(int size)
    {
        return new Random().nextInt(size);
    }

    public static List<Assignment> getInitialPopulation(List<Employee> employees, List<Task> tasks, int populationSize)
    {
        List<Assignment> population = new ArrayList<>();

        for (int i = 0; i < populationSize; i++)
        {
            Assignment assignment = new Assignment();
            // Randomly assign each task to an employee
            for (Task task : tasks)
            {
                String employeeId = employees.get(getRandomEmployeeIndex(employees.size())).getId();
                assignment.assign(task.getId(), employeeId);
            }
            population.add(assignment);
        }
        return population;
    }
}
**************************************************

File: DataGenerator.java
**************************************************
package Utilities;

import Model.Task;
import Model.Employee;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Arrays;

/**
 * Utility class for generating or loading task and employee data.
 */
public class DataGenerator {

    // Default file paths in resources
    private static final String DEFAULT_TASKS_FILE = "/taskData.csv";
    private static final String DEFAULT_EMPLOYEES_FILE = "/employeeData.csv";

    /**
     * Loads task data from the default CSV file.
     *
     * @return List of Task objects
     * @throws IOException If an I/O error occurs
     */
    public static List<Task> loadTasks() throws IOException {
        return loadTasks(DEFAULT_TASKS_FILE);
    }

    /**
     * Loads task data from a specific CSV file.
     *
     * @param filePath Path to the CSV file (relative to resources)
     * @return List of Task objects
     * @throws IOException If an I/O error occurs
     */
    public static List<Task> loadTasks(String filePath) throws IOException {
        List<Task> tasks = new ArrayList<>();

        try (InputStream is = DataGenerator.class.getResourceAsStream(filePath);
             BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {

            // Skip header line
            String line = reader.readLine();

            // Read data lines
            while ((line = reader.readLine()) != null) {
                String[] data = line.split(",");
                if (data.length >= 5) {
                    String id = data[0].trim();
                    int estimatedTime = Integer.parseInt(data[1].trim());
                    int difficulty = Integer.parseInt(data[2].trim());
                    int deadline = Integer.parseInt(data[3].trim());
                    String requiredSkill = data[4].trim();

                    Task task = new Task(id, estimatedTime, difficulty, deadline, requiredSkill);
                    tasks.add(task);
                }
            }
        }

        return tasks;
    }

    /**
     * Loads employee data from the default CSV file.
     *
     * @return List of Employee objects
     * @throws IOException If an I/O error occurs
     */
    public static List<Employee> loadEmployees() throws IOException {
        return loadEmployees(DEFAULT_EMPLOYEES_FILE);
    }

    /**
     * Loads employee data from a specific CSV file.
     *
     * @param filePath Path to the CSV file (relative to resources)
     * @return List of Employee objects
     * @throws IOException If an I/O error occurs
     */
    public static List<Employee> loadEmployees(String filePath) throws IOException {
        List<Employee> employees = new ArrayList<>();

        try (InputStream is = DataGenerator.class.getResourceAsStream(filePath);
             BufferedReader reader = new BufferedReader(new InputStreamReader(is))) {

            // Skip header line
            String line = reader.readLine();

            // Read data lines
            while ((line = reader.readLine()) != null) {
                String[] data = line.split(",");
                if (data.length >= 4) {
                    String id = data[0].trim();
                    int availableHours = Integer.parseInt(data[1].trim());
                    int skillLevel = Integer.parseInt(data[2].trim());

                    // Parse skills (comma-separated list, potentially in quotes with spaces)
                    String skillsStr = data[3].trim();
                    System.out.println(skillsStr);
                    String[] skillsArray = skillsStr.split(" ");
                    Set<String> skills = new HashSet<>(Arrays.asList(skillsArray));

                    Employee employee = new Employee(id, availableHours, skillLevel, skills);
                    employees.add(employee);
                }
            }
        }

        return employees;
    }

}
**************************************************

File: Main.java
**************************************************
import deprecated.GeneticAlgorithm;
import Model.Assignment;
import Model.Employee;
import Model.Task;
import Utilities.DataGenerator;
import Utilities.Initialise;

import java.util.List;

public class Main
{
    public static void main(String[] args)
    {

        try
        {
            List<Task> tasks = DataGenerator.loadTasks();
            List<Employee> employees = DataGenerator.loadEmployees();

            // Print loaded data
            printLoadedData(tasks, employees);

            // Create initial population
            List<Assignment> population = Initialise.getInitialPopulation(employees, tasks, 1);

            Assignment testAssignment = population.getFirst();
            System.out.println(testAssignment.toString());
            System.out.println("=====================\n Running Genetic Algorithm\n");
            GeneticAlgorithm ga = new GeneticAlgorithm(tasks, employees, 1, 30, 10, -1, false);
            ga.run();
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
    }

    private static void printLoadedData(List<Task> tasks, List<Employee> employees)
    {
        System.out.println("Tasks:");
        for (Task task : tasks)
        {
            System.out.println("  " + task);
        }

        System.out.println("\nEmployees:");
        for (Employee employee : employees)
        {
            System.out.println("  " + employee);
        }
    }
}
**************************************************

File: Assignment.java
**************************************************
package Model;

import Utilities.CostCalculator;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Represents an assignment of tasks to employees.
 * This class is used to store and manipulate a solution for the task assignment problem.
 */

public class Assignment
{
    private final Map<String, String> taskToEmployeeMap;

    // Cache for storing calculated values like overload, skill mismatch, etc.
    private double cachedCost = -1;

    // Penalty weights
    private static final double OVERLOAD_WEIGHT = 0.33;
    private static final double SKILL_MISMATCH_WEIGHT = 0.33;
    private static final double DEADLINE_VIOLATION_WEIGHT = 0.34;


    public Assignment() {
        this.taskToEmployeeMap = new HashMap<>();
    }

    public Assignment(Assignment other) {
        this.taskToEmployeeMap = new HashMap<>(other.taskToEmployeeMap);
    }

    // Assign a task to employee
    public void assign(String taskId, String employeeId) {
        taskToEmployeeMap.put(taskId, employeeId);
        // Invalidate cache when assignment changes
        cachedCost = -1;
    }

    public String getAssignedEmployee(String taskId) {
        return taskToEmployeeMap.get(taskId);
    }

    public List<Task> getAssignedTasks(String employeeId, List<Task> tasks) {
        List<Task> assignedTasks = new ArrayList<>();

        for (Task task : tasks) {
            String assignedEmployeeId = getAssignedEmployee(task.getId());
            if (employeeId.equals(assignedEmployeeId)) {
                assignedTasks.add(task);
            }
        }

        return assignedTasks;
    }

    public boolean isComplete(List<Task> tasks) {
        for (Task task : tasks) {
            if (!taskToEmployeeMap.containsKey(task.getId())) {
                return false;
            }
        }
        return true;
    }

    public int calculateTotalWorkingTime(String employeeId, List<Task> tasks) {
        List<Task> assignedTasks = getAssignedTasks(employeeId, tasks);

        int totalTime = 0;
        for (Task task : assignedTasks) {
            totalTime += task.getEstimatedTime();
        }

        return totalTime;
    }

    public double calculateOverloadPenalty(Employee employee, List<Task> tasks) {
        int totalTime = calculateTotalWorkingTime(employee.getId(), tasks);
        int overload = Math.max(0, totalTime - employee.getAvailableHours());

        return overload;
    }

    public double calculateSkillMismatchPenalty(List<Employee> employees, List<Task> tasks) {
        return CostCalculator.calculateSkillMismatchPenalty(this, tasks, employees);
    }

    public double calculateDeadlineViolationPenalty(List<Employee> employees, List<Task> tasks) {
        return CostCalculator.calculateDeadlineViolationPenalty(this, tasks, employees);
    }

    public double calculateCost(List<Employee> employees, List<Task> tasks) {
        if (cachedCost >= 0) {
            return cachedCost;
        }

        cachedCost = CostCalculator.calculateTotalCost(this, tasks, employees);

        return cachedCost;
    }


    private Employee findEmployeeById(List<Employee> employees, String employeeId) {
        for (Employee employee : employees) {
            if (employee.getId().equals(employeeId)) {
                return employee;
            }
        }
        return null;
    }


    public Map<String, String> getTaskToEmployeeMap() {
        return Map.copyOf(taskToEmployeeMap);
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append("Assignment:\n");

        for (Map.Entry<String, String> entry : taskToEmployeeMap.entrySet()) {
            sb.append("  Task ").append(entry.getKey())
                    .append(" -> Employee ").append(entry.getValue())
                    .append("\n");
        }

        return sb.toString();
    }

}

**************************************************

File: Task.java
**************************************************
package Model;

public class Task
{
    private final String id;
    private final int estimatedTime;  // in hours
    private final int difficulty;     // skill level required
    private final int deadline;       // hours from now
    private final String requiredSkill;


    public Task(String id, int estimatedTime, int difficulty, int deadline, String requiredSkill) {
        this.id = id;
        this.estimatedTime = estimatedTime;
        this.difficulty = difficulty;
        this.deadline = deadline;
        this.requiredSkill = requiredSkill;
    }

    public String getId()
    {
        return id;
    }

    public int getEstimatedTime() {
        return estimatedTime;
    }

    public int getDifficulty() {
        return difficulty;
    }

    public int getDeadline() {
        return deadline;
    }

    public String getRequiredSkill() {
        return requiredSkill;
    }

    @Override
    public String toString() {
        return "Task{" +
                "id='" + id + '\'' +
                ", estimatedTime=" + estimatedTime +
                ", difficulty=" + difficulty +
                ", deadline=" + deadline +
                ", requiredSkill='" + requiredSkill + '\'' +
                '}';
    }
}

**************************************************

File: Employee.java
**************************************************
package Model;

import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

public class Employee
{
    private final String id;
    private final int availableHours;
    private final int skillLevel;
    private final Set<String> skills;

    public Employee(String ID, int hours, int skillLevel, Set<String> skills)
    {
        this.id = ID;
        this.availableHours = hours;
        this.skillLevel = skillLevel;
        this.skills = new HashSet<>(skills);
    }

    public String getId()
    {
        return id;
    }

    public int getAvailableHours()
    {
        return availableHours;
    }

    public int getSkillLevel()
    {
        return skillLevel;
    }

    public Set<String> getSkills()
    {
        return Collections.unmodifiableSet(skills);
    }

    public boolean hasSkill(String skill)
    {
        return skills.contains(skill);
    }

    public boolean canPerformTask(Task task)
    {
        return skillLevel >= task.getDifficulty() && hasSkill(task.getRequiredSkill());
    }

    @Override
    public String toString() {
        return "Employee{" +
                "id='" + id + '\'' +
                ", availableHours=" + availableHours +
                ", skillLevel=" + skillLevel +
                ", skills=" + skills +
                '}';
    }

}
**************************************************

